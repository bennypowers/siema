{"version":3,"file":"siema.min.js","sources":["../src/siema.js"],"sourcesContent":["/**\n * Hi :-) This is a class representing a Siema.\n */\nexport default class Siema {\n  /**\n   * Create a Siema.\n   * @param {Object} options - Optional settings object.\n   */\n  constructor(options) {\n    // Merge defaults with user's settings\n    this.config = Siema.mergeSettings(options);\n\n    // Resolve selector's type\n    this.selector = typeof this.config.selector === 'string' ? document.querySelector(this.config.selector) : this.config.selector;\n\n    // Early throw if selector doesn't exists\n    if (this.selector === null) {\n      throw new Error('Something wrong with your selector ðŸ˜­');\n    }\n\n    // update perPage number dependable of user value\n    this.resolveSlidesNumber();\n\n    // Create global references\n    this.selectorWidth = this.selector.offsetWidth;\n    this.innerElements = [].slice.call(this.selector.children);\n    this.currentSlide = this.config.loop ?\n      this.config.startIndex % this.innerElements.length :\n      Math.max(0, Math.min(this.config.startIndex, this.innerElements.length - this.perPage));\n    this.transformProperty = Siema.webkitOrNot();\n\n    // Bind all event handlers for referencability\n    ['resizeHandler', 'touchstartHandler', 'touchendHandler', 'touchmoveHandler', 'mousedownHandler', 'mouseupHandler', 'mouseleaveHandler', 'mousemoveHandler', 'clickHandler'].forEach(method => {\n      this[method] = this[method].bind(this);\n    });\n\n    // Build markup and apply required styling to elements\n    this.init();\n  }\n\n\n  /**\n   * Overrides default settings with custom ones.\n   * @param {Object} options - Optional settings object.\n   * @returns {Object} - Custom Siema settings.\n   */\n  static mergeSettings(options) {\n    const settings = {\n      selector: '.siema',\n      duration: 200,\n      easing: 'ease-out',\n      perPage: 1,\n      startIndex: 0,\n      draggable: true,\n      multipleDrag: true,\n      threshold: 20,\n      loop: false,\n      rtl: false,\n      onInit: () => {},\n      onChange: () => {},\n    };\n\n    const userSttings = options;\n    for (const attrname in userSttings) {\n      settings[attrname] = userSttings[attrname];\n    }\n\n    return settings;\n  }\n\n\n  /**\n   * Determine if browser supports unprefixed transform property.\n   * Google Chrome since version 26 supports prefix-less transform\n   * @returns {string} - Transform property supported by client.\n   */\n  static webkitOrNot() {\n    const style = document.documentElement.style;\n    if (typeof style.transform === 'string') {\n      return 'transform';\n    }\n    return 'WebkitTransform';\n  }\n\n  /**\n   * Attaches listeners to required events.\n   */\n  attachEvents() {\n    // Resize element on window resize\n    window.addEventListener('resize', this.resizeHandler);\n\n    // If element is draggable / swipable, add event handlers\n    if (this.config.draggable) {\n      // Keep track pointer hold and dragging distance\n      this.pointerDown = false;\n      this.drag = {\n        startX: 0,\n        endX: 0,\n        startY: 0,\n        letItGo: null,\n        preventClick: false,\n      };\n\n      // Touch events\n      this.selector.addEventListener('touchstart', this.touchstartHandler);\n      this.selector.addEventListener('touchend', this.touchendHandler);\n      this.selector.addEventListener('touchmove', this.touchmoveHandler);\n\n      // Mouse events\n      this.selector.addEventListener('mousedown', this.mousedownHandler);\n      this.selector.addEventListener('mouseup', this.mouseupHandler);\n      this.selector.addEventListener('mouseleave', this.mouseleaveHandler);\n      this.selector.addEventListener('mousemove', this.mousemoveHandler);\n\n      // Click\n      this.selector.addEventListener('click', this.clickHandler);\n    }\n  }\n\n\n  /**\n   * Detaches listeners from required events.\n   */\n  detachEvents() {\n    window.removeEventListener('resize', this.resizeHandler);\n    this.selector.removeEventListener('touchstart', this.touchstartHandler);\n    this.selector.removeEventListener('touchend', this.touchendHandler);\n    this.selector.removeEventListener('touchmove', this.touchmoveHandler);\n    this.selector.removeEventListener('mousedown', this.mousedownHandler);\n    this.selector.removeEventListener('mouseup', this.mouseupHandler);\n    this.selector.removeEventListener('mouseleave', this.mouseleaveHandler);\n    this.selector.removeEventListener('mousemove', this.mousemoveHandler);\n    this.selector.removeEventListener('click', this.clickHandler);\n  }\n\n\n  /**\n   * Builds the markup and attaches listeners to required events.\n   */\n  init() {\n    this.attachEvents();\n\n    // hide everything out of selector's boundaries\n    this.selector.style.overflow = 'hidden';\n\n    // rtl or ltr\n    this.selector.style.direction = this.config.rtl ? 'rtl' : 'ltr';\n\n    // build a frame and slide to a currentSlide\n    this.buildSliderFrame();\n\n    this.config.onInit.call(this);\n  }\n\n\n  /**\n   * Build a sliderFrame and slide to a current item.\n   */\n  buildSliderFrame() {\n    const widthItem = this.selectorWidth / this.perPage;\n    const itemsToBuild = this.config.loop ? this.innerElements.length + (2 * this.perPage) : this.innerElements.length;\n\n    // Create frame and apply styling\n    this.sliderFrame = document.createElement('div');\n    this.sliderFrame.style.width = `${widthItem * itemsToBuild}px`;\n    this.enableTransition();\n\n    if (this.config.draggable) {\n      this.selector.style.cursor = '-webkit-grab';\n    }\n\n    // Create a document fragment to put slides into it\n    const docFragment = document.createDocumentFragment();\n\n    // Loop through the slides, add styling and add them to document fragment\n    if (this.config.loop) {\n      for (let i = this.innerElements.length - this.perPage; i < this.innerElements.length; i++) {\n        const element = this.buildSliderFrameItem(this.innerElements[i].cloneNode(true));\n        docFragment.appendChild(element);\n      }\n    }\n    for (let i = 0; i < this.innerElements.length; i++) {\n      const element = this.buildSliderFrameItem(this.innerElements[i]);\n      docFragment.appendChild(element);\n    }\n    if (this.config.loop) {\n      for (let i = 0; i < this.perPage; i++) {\n        const element = this.buildSliderFrameItem(this.innerElements[i].cloneNode(true));\n        docFragment.appendChild(element);\n      }\n    }\n\n    // Add fragment to the frame\n    this.sliderFrame.appendChild(docFragment);\n\n    // Clear selector (just in case something is there) and insert a frame\n    this.selector.innerHTML = '';\n    this.selector.appendChild(this.sliderFrame);\n\n    // Go to currently active slide after initial build\n    this.slideToCurrent();\n  }\n\n  buildSliderFrameItem(elm) {\n    const elementContainer = document.createElement('div');\n    elementContainer.style.cssFloat = this.config.rtl ? 'right' : 'left';\n    elementContainer.style.float = this.config.rtl ? 'right' : 'left';\n    elementContainer.style.width = `${this.config.loop ? 100 / (this.innerElements.length + (this.perPage * 2)) : 100 / (this.innerElements.length)}%`;\n    elementContainer.appendChild(elm);\n    return elementContainer;\n  }\n\n\n  /**\n   * Determinates slides number accordingly to clients viewport.\n   */\n  resolveSlidesNumber() {\n    if (typeof this.config.perPage === 'number') {\n      this.perPage = this.config.perPage;\n    }\n    else if (typeof this.config.perPage === 'object') {\n      this.perPage = 1;\n      for (const viewport in this.config.perPage) {\n        if (window.innerWidth >= viewport) {\n          this.perPage = this.config.perPage[viewport];\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Go to previous slide.\n   * @param {number} [howManySlides=1] - How many items to slide backward.\n   * @param {function} callback - Optional callback function.\n   */\n  prev(howManySlides = 1, callback) {\n    // early return when there is nothing to slide\n    if (this.innerElements.length <= this.perPage) {\n      return;\n    }\n\n    const beforeChange = this.currentSlide;\n\n    if (this.config.loop) {\n      const isNewIndexClone = this.currentSlide - howManySlides < 0;\n      if (isNewIndexClone) {\n        this.disableTransition();\n\n        const mirrorSlideIndex = this.currentSlide + this.innerElements.length;\n        const mirrorSlideIndexOffset = this.perPage;\n        const moveTo = mirrorSlideIndex + mirrorSlideIndexOffset;\n        const offset = (this.config.rtl ? 1 : -1) * moveTo * (this.selectorWidth / this.perPage);\n        const dragDistance = this.config.draggable ? this.drag.endX - this.drag.startX : 0;\n\n        this.sliderFrame.style[this.transformProperty] = `translate3d(${offset + dragDistance}px, 0, 0)`;\n        this.currentSlide = mirrorSlideIndex - howManySlides;\n      }\n      else {\n        this.currentSlide = this.currentSlide - howManySlides;\n      }\n    }\n    else {\n      this.currentSlide = Math.max(this.currentSlide - howManySlides, 0);\n    }\n\n    if (beforeChange !== this.currentSlide) {\n      this.slideToCurrent(this.config.loop);\n      this.config.onChange.call(this);\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n\n\n  /**\n   * Go to next slide.\n   * @param {number} [howManySlides=1] - How many items to slide forward.\n   * @param {function} callback - Optional callback function.\n   */\n  next(howManySlides = 1, callback) {\n    // early return when there is nothing to slide\n    if (this.innerElements.length <= this.perPage) {\n      return;\n    }\n\n    const beforeChange = this.currentSlide;\n\n    if (this.config.loop) {\n      const isNewIndexClone = this.currentSlide + howManySlides > this.innerElements.length - this.perPage;\n      if (isNewIndexClone) {\n        this.disableTransition();\n\n        const mirrorSlideIndex = this.currentSlide - this.innerElements.length;\n        const mirrorSlideIndexOffset = this.perPage;\n        const moveTo = mirrorSlideIndex + mirrorSlideIndexOffset;\n        const offset = (this.config.rtl ? 1 : -1) * moveTo * (this.selectorWidth / this.perPage);\n        const dragDistance = this.config.draggable ? this.drag.endX - this.drag.startX : 0;\n\n        this.sliderFrame.style[this.transformProperty] = `translate3d(${offset + dragDistance}px, 0, 0)`;\n        this.currentSlide = mirrorSlideIndex + howManySlides;\n      }\n      else {\n        this.currentSlide = this.currentSlide + howManySlides;\n      }\n    }\n    else {\n      this.currentSlide = Math.min(this.currentSlide + howManySlides, this.innerElements.length - this.perPage);\n    }\n    if (beforeChange !== this.currentSlide) {\n      this.slideToCurrent(this.config.loop);\n      this.config.onChange.call(this);\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n\n\n  /**\n   * Disable transition on sliderFrame.\n   */\n  disableTransition() {\n    this.sliderFrame.style.webkitTransition = `all 0ms ${this.config.easing}`;\n    this.sliderFrame.style.transition = `all 0ms ${this.config.easing}`;\n  }\n\n\n  /**\n   * Enable transition on sliderFrame.\n   */\n  enableTransition() {\n    this.sliderFrame.style.webkitTransition = `all ${this.config.duration}ms ${this.config.easing}`;\n    this.sliderFrame.style.transition = `all ${this.config.duration}ms ${this.config.easing}`;\n  }\n\n\n  /**\n   * Go to slide with particular index\n   * @param {number} index - Item index to slide to.\n   * @param {function} callback - Optional callback function.\n   */\n  goTo(index, callback) {\n    if (this.innerElements.length <= this.perPage) {\n      return;\n    }\n    const beforeChange = this.currentSlide;\n    this.currentSlide = this.config.loop ?\n      index % this.innerElements.length :\n      Math.min(Math.max(index, 0), this.innerElements.length - this.perPage);\n    if (beforeChange !== this.currentSlide) {\n      this.slideToCurrent();\n      this.config.onChange.call(this);\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n\n\n  /**\n   * Moves sliders frame to position of currently active slide\n   */\n  slideToCurrent(enableTransition) {\n    const currentSlide = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide;\n    const offset = (this.config.rtl ? 1 : -1) * currentSlide * (this.selectorWidth / this.perPage);\n\n    if (enableTransition) {\n      // This one is tricky, I know but this is a perfect explanation:\n      // https://youtu.be/cCOL7MC4Pl0\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          this.enableTransition();\n          this.sliderFrame.style[this.transformProperty] = `translate3d(${offset}px, 0, 0)`;\n        });\n      });\n    }\n    else {\n      this.sliderFrame.style[this.transformProperty] = `translate3d(${offset}px, 0, 0)`;\n    }\n  }\n\n\n  /**\n   * Recalculate drag /swipe event and reposition the frame of a slider\n   */\n  updateAfterDrag() {\n    const movement = (this.config.rtl ? -1 : 1) * (this.drag.endX - this.drag.startX);\n    const movementDistance = Math.abs(movement);\n    const howManySliderToSlide = this.config.multipleDrag ? Math.ceil(movementDistance / (this.selectorWidth / this.perPage)) : 1;\n\n    const slideToNegativeClone = movement > 0 && this.currentSlide - howManySliderToSlide < 0;\n    const slideToPositiveClone = movement < 0 && this.currentSlide + howManySliderToSlide > this.innerElements.length - this.perPage;\n\n    if (movement > 0 && movementDistance > this.config.threshold && this.innerElements.length > this.perPage) {\n      this.prev(howManySliderToSlide);\n    }\n    else if (movement < 0 && movementDistance > this.config.threshold && this.innerElements.length > this.perPage) {\n      this.next(howManySliderToSlide);\n    }\n    this.slideToCurrent(slideToNegativeClone || slideToPositiveClone);\n  }\n\n\n  /**\n   * When window resizes, resize slider components as well\n   */\n  resizeHandler() {\n    // update perPage number dependable of user value\n    this.resolveSlidesNumber();\n\n    // relcalculate currentSlide\n    // prevent hiding items when browser width increases\n    if (this.currentSlide + this.perPage > this.innerElements.length) {\n      this.currentSlide = this.innerElements.length <= this.perPage ? 0 : this.innerElements.length - this.perPage;\n    }\n\n    this.selectorWidth = this.selector.offsetWidth;\n\n    this.buildSliderFrame();\n  }\n\n\n  /**\n   * Clear drag after touchend and mouseup event\n   */\n  clearDrag() {\n    this.drag = {\n      startX: 0,\n      endX: 0,\n      startY: 0,\n      letItGo: null,\n      preventClick: this.drag.preventClick\n    };\n  }\n\n\n  /**\n   * touchstart event handler\n   */\n  touchstartHandler(e) {\n    // Prevent dragging / swiping on inputs, selects and textareas\n    const ignoreSiema = ['TEXTAREA', 'OPTION', 'INPUT', 'SELECT'].indexOf(e.target.nodeName) !== -1;\n    if (ignoreSiema) {\n      return;\n    }\n\n    e.stopPropagation();\n    this.pointerDown = true;\n    this.drag.startX = e.touches[0].pageX;\n    this.drag.startY = e.touches[0].pageY;\n  }\n\n\n  /**\n   * touchend event handler\n   */\n  touchendHandler(e) {\n    e.stopPropagation();\n    this.pointerDown = false;\n    this.enableTransition();\n    if (this.drag.endX) {\n      this.updateAfterDrag();\n    }\n    this.clearDrag();\n  }\n\n\n  /**\n   * touchmove event handler\n   */\n  touchmoveHandler(e) {\n    e.stopPropagation();\n\n    if (this.drag.letItGo === null) {\n      this.drag.letItGo = Math.abs(this.drag.startY - e.touches[0].pageY) < Math.abs(this.drag.startX - e.touches[0].pageX);\n    }\n\n    if (this.pointerDown && this.drag.letItGo) {\n      e.preventDefault();\n      this.drag.endX = e.touches[0].pageX;\n      this.sliderFrame.style.webkitTransition = `all 0ms ${this.config.easing}`;\n      this.sliderFrame.style.transition = `all 0ms ${this.config.easing}`;\n\n      const currentSlide = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide;\n      const currentOffset = currentSlide * (this.selectorWidth / this.perPage);\n      const dragOffset = (this.drag.endX - this.drag.startX);\n      const offset = this.config.rtl ? currentOffset + dragOffset : currentOffset - dragOffset;\n      this.sliderFrame.style[this.transformProperty] = `translate3d(${(this.config.rtl ? 1 : -1) * offset}px, 0, 0)`;\n    }\n  }\n\n\n  /**\n   * mousedown event handler\n   */\n  mousedownHandler(e) {\n    // Prevent dragging / swiping on inputs, selects and textareas\n    const ignoreSiema = ['TEXTAREA', 'OPTION', 'INPUT', 'SELECT'].indexOf(e.target.nodeName) !== -1;\n    if (ignoreSiema) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n    this.pointerDown = true;\n    this.drag.startX = e.pageX;\n  }\n\n\n  /**\n   * mouseup event handler\n   */\n  mouseupHandler(e) {\n    e.stopPropagation();\n    this.pointerDown = false;\n    this.selector.style.cursor = '-webkit-grab';\n    this.enableTransition();\n    if (this.drag.endX) {\n      this.updateAfterDrag();\n    }\n    this.clearDrag();\n  }\n\n\n  /**\n   * mousemove event handler\n   */\n  mousemoveHandler(e) {\n    e.preventDefault();\n    if (this.pointerDown) {\n      // if dragged element is a link\n      // mark preventClick prop as a true\n      // to detemine about browser redirection later on\n      if (e.target.nodeName === 'A') {\n        this.drag.preventClick = true;\n      }\n\n      this.drag.endX = e.pageX;\n      this.selector.style.cursor = '-webkit-grabbing';\n      this.sliderFrame.style.webkitTransition = `all 0ms ${this.config.easing}`;\n      this.sliderFrame.style.transition = `all 0ms ${this.config.easing}`;\n\n      const currentSlide = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide;\n      const currentOffset = currentSlide * (this.selectorWidth / this.perPage);\n      const dragOffset = (this.drag.endX - this.drag.startX);\n      const offset = this.config.rtl ? currentOffset + dragOffset : currentOffset - dragOffset;\n      this.sliderFrame.style[this.transformProperty] = `translate3d(${(this.config.rtl ? 1 : -1) * offset}px, 0, 0)`;\n    }\n  }\n\n\n  /**\n   * mouseleave event handler\n   */\n  mouseleaveHandler(e) {\n    if (this.pointerDown) {\n      this.pointerDown = false;\n      this.selector.style.cursor = '-webkit-grab';\n      this.drag.endX = e.pageX;\n      this.drag.preventClick = false;\n      this.enableTransition();\n      this.updateAfterDrag();\n      this.clearDrag();\n    }\n  }\n\n\n  /**\n   * click event handler\n   */\n  clickHandler(e) {\n    // if the dragged element is a link\n    // prevent browsers from folowing the link\n    if (this.drag.preventClick) {\n      e.preventDefault();\n    }\n    this.drag.preventClick = false;\n  }\n\n\n  /**\n   * Remove item from carousel.\n   * @param {number} index - Item index to remove.\n   * @param {function} callback - Optional callback to call after remove.\n   */\n  remove(index, callback) {\n    if (index < 0 || index >= this.innerElements.length) {\n      throw new Error('Item to remove doesn\\'t exist ðŸ˜­');\n    }\n\n    // Shift sliderFrame back by one item when:\n    // 1. Item with lower index than currenSlide is removed.\n    // 2. Last item is removed.\n    const lowerIndex = index < this.currentSlide;\n    const lastItem = this.currentSlide + this.perPage - 1 === index;\n\n    if (lowerIndex || lastItem) {\n      this.currentSlide--;\n    }\n\n    this.innerElements.splice(index, 1);\n\n    // build a frame and slide to a currentSlide\n    this.buildSliderFrame();\n\n    if (callback) {\n      callback.call(this);\n    }\n  }\n\n\n  /**\n   * Insert item to carousel at particular index.\n   * @param {HTMLElement} item - Item to insert.\n   * @param {number} index - Index of new new item insertion.\n   * @param {function} callback - Optional callback to call after insert.\n   */\n  insert(item, index, callback) {\n    if (index < 0 || index > this.innerElements.length + 1) {\n      throw new Error('Unable to inset it at this index ðŸ˜­');\n    }\n    if (this.innerElements.indexOf(item) !== -1) {\n      throw new Error('The same item in a carousel? Really? Nope ðŸ˜­');\n    }\n\n    // Avoid shifting content\n    const shouldItShift = index <= this.currentSlide > 0 && this.innerElements.length;\n    this.currentSlide = shouldItShift ? this.currentSlide + 1 : this.currentSlide;\n\n    this.innerElements.splice(index, 0, item);\n\n    // build a frame and slide to a currentSlide\n    this.buildSliderFrame();\n\n    if (callback) {\n      callback.call(this);\n    }\n  }\n\n\n  /**\n   * Prepernd item to carousel.\n   * @param {HTMLElement} item - Item to prepend.\n   * @param {function} callback - Optional callback to call after prepend.\n   */\n  prepend(item, callback) {\n    this.insert(item, 0);\n    if (callback) {\n      callback.call(this);\n    }\n  }\n\n\n  /**\n   * Append item to carousel.\n   * @param {HTMLElement} item - Item to append.\n   * @param {function} callback - Optional callback to call after append.\n   */\n  append(item, callback) {\n    this.insert(item, this.innerElements.length + 1);\n    if (callback) {\n      callback.call(this);\n    }\n  }\n\n\n  /**\n   * Removes listeners and optionally restores to initial markup\n   * @param {boolean} restoreMarkup - Determinants about restoring an initial markup.\n   * @param {function} callback - Optional callback function.\n   */\n  destroy(restoreMarkup = false, callback) {\n    this.detachEvents();\n\n    this.selector.style.cursor = 'auto';\n\n    if (restoreMarkup) {\n      const slides = document.createDocumentFragment();\n      for (let i = 0; i < this.innerElements.length; i++) {\n        slides.appendChild(this.innerElements[i]);\n      }\n      this.selector.innerHTML = '';\n      this.selector.appendChild(slides);\n      this.selector.removeAttribute('style');\n    }\n\n    if (callback) {\n      callback.call(this);\n    }\n  }\n}\n"],"names":["Siema","options","config","mergeSettings","selector","this","document","querySelector","Error","resolveSlidesNumber","selectorWidth","offsetWidth","innerElements","slice","call","children","currentSlide","loop","startIndex","length","Math","max","min","perPage","transformProperty","webkitOrNot","forEach","method","bind","init","settings","userSttings","attrname","documentElement","style","transform","addEventListener","resizeHandler","draggable","pointerDown","drag","touchstartHandler","touchendHandler","touchmoveHandler","mousedownHandler","mouseupHandler","mouseleaveHandler","mousemoveHandler","clickHandler","removeEventListener","attachEvents","overflow","direction","rtl","buildSliderFrame","onInit","widthItem","itemsToBuild","sliderFrame","createElement","width","enableTransition","cursor","docFragment","createDocumentFragment","i","element","buildSliderFrameItem","cloneNode","appendChild","innerHTML","slideToCurrent","elm","elementContainer","cssFloat","float","viewport","window","innerWidth","howManySlides","callback","beforeChange","disableTransition","mirrorSlideIndex","moveTo","offset","dragDistance","endX","startX","onChange","webkitTransition","easing","transition","duration","index","movement","movementDistance","abs","howManySliderToSlide","multipleDrag","ceil","slideToNegativeClone","slideToPositiveClone","threshold","prev","next","preventClick","e","indexOf","target","nodeName","stopPropagation","touches","pageX","startY","pageY","updateAfterDrag","clearDrag","letItGo","preventDefault","currentOffset","dragOffset","lowerIndex","lastItem","splice","item","shouldItShift","insert","restoreMarkup","detachEvents","slides","removeAttribute"],"mappings":"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"}